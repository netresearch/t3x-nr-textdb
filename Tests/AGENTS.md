<!-- Managed by agent: keep sections & order; edit content, not structure. Last updated: 2025-11-07 -->

# Tests/AGENTS.md

PHPUnit testing infrastructure for nr_textdb TYPO3 extension.

## 1. Overview

Unit and functional tests using TYPO3 Testing Framework:

- **Unit/**: Isolated unit tests (no TYPO3 bootstrap)
- **Functional/**: Integration tests with database (if added later)

Current coverage: Unit tests for Domain models and services.

## 2. Setup & environment

**Prerequisites:**
- Same as Classes/AGENTS.md (PHP 8.1+, TYPO3 13.4+)
- TYPO3 Testing Framework: `typo3/testing-framework:^9.0`

**Installation:**
```bash
composer install  # Installs testing-framework in require-dev
```

**Test configuration:**
- Config: `Build/UnitTests.xml`
- Coverage reports: Generated by Xdebug/PCOV
- Namespace: `Netresearch\NrTextdb\Tests\`

## 3. Build & tests

**Run from project root:**

```bash
# Run unit tests with coverage
composer ci:test:php:unit

# Or directly with PHPUnit
XDEBUG_MODE=coverage .build/bin/phpunit -c Build/UnitTests.xml

# Run specific test class
.build/bin/phpunit -c Build/UnitTests.xml Tests/Unit/Domain/Model/SomeTest.php

# Run without coverage (faster)
.build/bin/phpunit -c Build/UnitTests.xml --no-coverage

# Verbose output
.build/bin/phpunit -c Build/UnitTests.xml --testdox
```

**Test structure:**
- Unit tests: `Tests/Unit/` mirrors `Classes/` structure
- Example: `Classes/Domain/Model/Foo.php` → `Tests/Unit/Domain/Model/FooTest.php`

## 4. Code style & conventions

**PHPUnit patterns:**
- Extend `TYPO3\TestingFramework\Core\Unit\UnitTestCase` for unit tests
- Use `setUp()` and `tearDown()` for test fixtures
- Test method naming: `test` prefix + descriptive name
- Use data providers for multiple test cases
- Mock dependencies with `createMock()` or `getMockBuilder()`

**Assertions:**
- Use specific assertions: `assertSame()` over `assertEquals()`
- Use `assertInstanceOf()` for type checks
- Use `expectException()` for exception testing

**File structure:**
```php
<?php

declare(strict_types=1);

namespace Netresearch\NrTextdb\Tests\Unit\Domain\Model;

use Netresearch\NrTextdb\Domain\Model\Translation;
use TYPO3\TestingFramework\Core\Unit\UnitTestCase;

final class TranslationTest extends UnitTestCase
{
    private Translation $subject;

    protected function setUp(): void
    {
        parent::setUp();
        $this->subject = new Translation();
    }

    /**
     * @test
     */
    public function getKeyReturnsInitialValue(): void
    {
        self::assertSame('', $this->subject->getKey());
    }
}
```

## 5. Security & safety

**Test data:**
- Never use production data in tests
- Use realistic but fake data
- Don't commit test databases or fixtures with sensitive info

**Test isolation:**
- Unit tests must not touch database, filesystem, or network
- Use mocks/stubs for external dependencies
- Clean up after tests (in `tearDown()`)

**Coverage:**
- Aim for >80% code coverage on critical paths
- Don't test getters/setters unless they have logic
- Focus on business logic, edge cases, error handling

## 6. PR/commit checklist

Before committing Tests/ changes:

- [ ] All tests pass: `composer ci:test:php:unit`
- [ ] New tests for new functionality in Classes/
- [ ] Tests follow naming convention: `*Test.php`
- [ ] Tests use `@test` annotation or `test` prefix
- [ ] Mocks used for dependencies (no real DB/files)
- [ ] `declare(strict_types=1);` at top of test file
- [ ] Extends appropriate base class (`UnitTestCase`)
- [ ] No skipped/incomplete tests without reason
- [ ] Test names describe what is being tested

## 7. Good vs. bad examples

### ✅ Good: Unit test with mocking

```php
<?php

declare(strict_types=1);

namespace Netresearch\NrTextdb\Tests\Unit\Service;

use Netresearch\NrTextdb\Domain\Repository\TranslationRepository;
use Netresearch\NrTextdb\Service\TranslationService;
use TYPO3\TestingFramework\Core\Unit\UnitTestCase;

final class TranslationServiceTest extends UnitTestCase
{
    /**
     * @test
     */
    public function findByLanguageReturnsMockedResults(): void
    {
        $mockRepository = $this->createMock(TranslationRepository::class);
        $mockRepository->method('findByLanguage')
            ->with('de')
            ->willReturn(['key1' => 'value1']);

        $service = new TranslationService($mockRepository);
        $result = $service->getTranslations('de');

        self::assertSame(['key1' => 'value1'], $result);
    }
}
```

### ❌ Bad: No mocking, unclear test name

```php
<?php

namespace Netresearch\NrTextdb\Tests\Unit\Service;

use TYPO3\TestingFramework\Core\Unit\UnitTestCase;

class TranslationServiceTest extends UnitTestCase
{
    public function testIt()
    {
        // What is "it"? What are we testing?
        $service = new TranslationService();  // Missing dependency
        $result = $service->getTranslations('de');
        $this->assertTrue(true);  // Meaningless assertion
    }
}
```

### ✅ Good: Data provider for multiple cases

```php
<?php

declare(strict_types=1);

namespace Netresearch\NrTextdb\Tests\Unit\Domain\Model;

use Netresearch\NrTextdb\Domain\Model\Translation;
use TYPO3\TestingFramework\Core\Unit\UnitTestCase;

final class TranslationTest extends UnitTestCase
{
    /**
     * @test
     * @dataProvider validLanguageCodesProvider
     */
    public function setLanguageAcceptsValidCodes(string $languageCode): void
    {
        $subject = new Translation();
        $subject->setLanguage($languageCode);

        self::assertSame($languageCode, $subject->getLanguage());
    }

    public function validLanguageCodesProvider(): array
    {
        return [
            'German' => ['de'],
            'English' => ['en'],
            'French' => ['fr'],
        ];
    }
}
```

### ❌ Bad: No data provider, repetitive tests

```php
<?php

class TranslationTest extends UnitTestCase
{
    public function testGerman()
    {
        $subject = new Translation();
        $subject->setLanguage('de');
        $this->assertEquals('de', $subject->getLanguage());
    }

    public function testEnglish()
    {
        $subject = new Translation();
        $subject->setLanguage('en');
        $this->assertEquals('en', $subject->getLanguage());
    }

    // Repetitive...
}
```

### ✅ Good: Exception testing

```php
<?php

declare(strict_types=1);

final class ValidationServiceTest extends UnitTestCase
{
    /**
     * @test
     */
    public function validateThrowsExceptionForInvalidInput(): void
    {
        $service = new ValidationService();

        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('Invalid language code');

        $service->validate('invalid-code');
    }
}
```

## 8. When stuck

**TYPO3 Testing Documentation:**
- Testing Framework: https://docs.typo3.org/m/typo3/reference-coreapi/main/en-us/Testing/Index.html
- Extension Testing: https://docs.typo3.org/m/typo3/reference-coreapi/main/en-us/Testing/ExtensionTesting.html

**PHPUnit Documentation:**
- Official docs: https://docs.phpunit.de/
- Assertions: https://docs.phpunit.de/en/10.5/assertions.html
- Mocking: https://docs.phpunit.de/en/10.5/test-doubles.html

**Project-specific:**
- Check existing test patterns in `Tests/Unit/`
- Review `Build/UnitTests.xml` for configuration
- Look at TYPO3 core tests for complex patterns

**Debugging tests:**
```bash
# Run with verbose output
.build/bin/phpunit -c Build/UnitTests.xml --testdox --colors

# Run single test method
.build/bin/phpunit -c Build/UnitTests.xml --filter testMethodName

# Debug with var_dump (or use Xdebug)
# Add var_dump() in test, run without coverage
```

## 9. House Rules

**Testing priorities:**
1. **Must test:** Business logic in Services, complex model methods
2. **Should test:** Controllers (action methods), Repositories (custom queries)
3. **Can skip:** Simple getters/setters, TYPO3 framework code

**TYPO3 Testing Framework specifics:**
- Use `UnitTestCase` for unit tests (no DB)
- Use `FunctionalTestCase` for integration tests (with DB) if added
- Respect test categorization: `@test` annotation
- Use TYPO3's assertion helpers when available

**Coverage expectations:**
- Services: >90% coverage
- Models: >80% coverage (skip trivial getters/setters)
- Controllers: >70% coverage
- ViewHelpers: >80% coverage
- Repositories: Custom methods >90%
